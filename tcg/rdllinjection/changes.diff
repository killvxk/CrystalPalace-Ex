diff --git a/ReflectiveDLLInjection/src/ReflectiveLoader.c b/ReflectiveDLLInjection/src/ReflectiveLoader.c
index 594c0b8..66e84d4 100644
--- a/ReflectiveDLLInjection/src/ReflectiveLoader.c
+++ b/ReflectiveDLLInjection/src/ReflectiveLoader.c
@@ -26,16 +26,9 @@
 // POSSIBILITY OF SUCH DAMAGE.
 //===============================================================================================//
 #include "ReflectiveLoader.h"
-//===============================================================================================//
-// Our loader will set this to a pseudo correct HINSTANCE/HMODULE value
-HINSTANCE hAppInstance = NULL;
-//===============================================================================================//
-#pragma intrinsic( _ReturnAddress )
-// This function can not be inlined by the compiler or we will not get the address we expect. Ideally 
-// this code will be compiled with the /O2 and /Ob1 switches. Bonus points if we could take advantage of 
-// RIP relative addressing in this instance but I dont believe we can do so with the compiler intrinsics 
-// available (and no inline asm available under x64).
-__declspec(noinline) ULONG_PTR caller( VOID ) { return (ULONG_PTR)_ReturnAddress(); }
+
+char * findAppendedDLL();
+
 //===============================================================================================//
 
 // Note 1: If you want to have your own DllMain, define REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN,  
@@ -81,28 +74,7 @@ DLLEXPORT ULONG_PTR WINAPI ReflectiveLoader( VOID )
 
 	// STEP 0: calculate our images current base address
 
-	// we will start searching backwards from our callers return address.
-	uiLibraryAddress = caller();
-
-	// loop through memory backwards searching for our images base address
-	// we dont need SEH style search as we shouldnt generate any access violations with this
-	while( TRUE )
-	{
-		if( ((PIMAGE_DOS_HEADER)uiLibraryAddress)->e_magic == IMAGE_DOS_SIGNATURE )
-		{
-			uiHeaderValue = ((PIMAGE_DOS_HEADER)uiLibraryAddress)->e_lfanew;
-			// some x64 dll's can trigger a bogus signature (IMAGE_DOS_SIGNATURE == 'POP r10'),
-			// we sanity check the e_lfanew with an upper threshold value of 1024 to avoid problems.
-			if( uiHeaderValue >= sizeof(IMAGE_DOS_HEADER) && uiHeaderValue < 1024 )
-			{
-				uiHeaderValue += uiLibraryAddress;
-				// break if we have found a valid MZ/PE header
-				if( ((PIMAGE_NT_HEADERS)uiHeaderValue)->Signature == IMAGE_NT_SIGNATURE )
-					break;
-			}
-		}
-		uiLibraryAddress--;
-	}
+	uiLibraryAddress = (ULONG_PTR)findAppendedDLL();
 
 	// STEP 1: process the kernels exports for the functions our loader needs...
 
@@ -458,39 +430,34 @@ DLLEXPORT ULONG_PTR WINAPI ReflectiveLoader( VOID )
 	pNtFlushInstructionCache( (HANDLE)-1, NULL, 0 );
 
 	// call our respective entry point, fudging our hInstance value
-#ifdef REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR
-	// if we are injecting a DLL via LoadRemoteLibraryR we call DllMain and pass in our parameter (via the DllMain lpReserved parameter)
-	((DLLMAIN)uiValueA)( (HINSTANCE)uiBaseAddress, DLL_PROCESS_ATTACH, lpParameter );
-#else
+
 	// if we are injecting an DLL via a stub we call DllMain with no parameter
 	((DLLMAIN)uiValueA)( (HINSTANCE)uiBaseAddress, DLL_PROCESS_ATTACH, NULL );
-#endif
 
 	// STEP 8: return our new entry point address so whatever called us can call DllMain() if needed.
 	return uiValueA;
 }
-//===============================================================================================//
-#ifndef REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN
 
-BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved )
-{
-    BOOL bReturnValue = TRUE;
-	switch( dwReason ) 
-    { 
-		case DLL_QUERY_HMODULE:
-			if( lpReserved != NULL )
-				*(HMODULE *)lpReserved = hAppInstance;
-			break;
-		case DLL_PROCESS_ATTACH:
-			hAppInstance = hinstDLL;
-			break;
-		case DLL_PROCESS_DETACH:
-		case DLL_THREAD_ATTACH:
-		case DLL_THREAD_DETACH:
-            break;
-    }
-	return bReturnValue;
-}
+// from: https://github.com/rapid7/ReflectiveDLLInjection/blob/81cde88bebaa9fe782391712518903b5923470fb/dll/src/ReflectiveLoader.c#L34C1-L46C1
+#ifdef __MINGW32__
+#define WIN_GET_CALLER() __builtin_extract_return_addr(__builtin_return_address(0))
+#else
+#pragma intrinsic(_ReturnAddress)
+#define WIN_GET_CALLER() _ReturnAddress()
+#endif
+
+char __DLLDATA__[0] __attribute__((section("my_dll")));
+
+#ifdef WIN_X86
+__declspec(noinline) ULONG_PTR caller( VOID ) { return (ULONG_PTR)WIN_GET_CALLER(); }
+#endif
+
+char * findAppendedDLL() {
+	return (char *)&__DLLDATA__;
+}
-//===============================================================================================//
diff --git a/ReflectiveDLLInjection/src/ReflectiveLoader.h b/ReflectiveDLLInjection/src/ReflectiveLoader.h
index 3797879..767fd5c 100644
--- a/ReflectiveDLLInjection/src/ReflectiveLoader.h
+++ b/ReflectiveDLLInjection/src/ReflectiveLoader.h
@@ -30,7 +30,7 @@
 //===============================================================================================//
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
-#include <Winsock2.h>
+#include <winsock2.h>
 #include <intrin.h>
 
 #include "ReflectiveDLLInjection.h"
